An (heuristic-based) implement of the TTP algorithm (only containing the triangle packing construction) from Paper: https://drops.dagstuhl.de/opus/volltexte/2022/16881/pdf/LIPIcs-MFCS-2022-83.pdf

It is a simple .cpp file. The code is written by c/c++.
It can generate a schedule for TTP-3 with n teams, where n mod 6 = 0 (in this case a triangle packing always exists).

The construction is based on a heuristic triangle packing.

The triangle packing is generated by a simple local search method (usually it can find the optimal packing):
① List n(n-1)/2 pairs (i, j) in a random way, where 1<=i<j<=n;
② Swap each pair of vertices (if the packing becomes bad, undo it), respectively; 
③ After all pairs: if there is an improvement, we restart this local search; if there is no improvement after 99 iterations, end.

After obtaining a triangle packing, we take each triangle as a super-team. We use a local search (swapping super-teams) based TTP algorithm to generate solutions:
① List m(m-1)/2 pairs (i, j) in a random way, where 1<=i<j<=m (m=n/3, the number of triangles);
② Swap each pair of triangles (if the solution becomes bad, undo it), respectively;
③ After all pairs: if there is an improvement, we restart this local search; if there is no improvement after 9 iterations, end.

The TTP algorithm only works for the case n mod 6 = 0 (for other cases, it does not guarantee a good performance).

There are two heuristic methods in the TTP algorithm:
① In the paper, the schedule contains three kinds of super-games (SG): normal/left/last. The design of each is unique.
In the code: the design of normal SG is unique; for left SG, there are 3 different designs; for last SG, there are 62 different designs. //The designs are obtained by a simple ILP on 6 teams (there are some restrictions on the home/away patterns). We arbitrarily selected some of them.
The designs can be found in normal_super_game.txt, normal_super_game.txt, and last_super_game.txt.
② In extending each SG between super-teams u_i and u_j, there are three teams {x_1, x_2, x_3} in u_i and three teams {y_1, y_2, y_3} in u_j.
For each super-team, there are 3!=6 ways to order the three teams. So, there are 3!*3!=36 ways to order these six teams.
We will use the best order of the best design.

Some parameters in the code:
int n: number of teams;
int f_opt: a 0/1 variable indicating the last two heuristic parts;
char *s: filname, e.g. Galaxy.

The information of the output scheudle: 
① It is a n*(2n-2) matrix;
② The i-th row indicates team i, the j-th column indicates the j-th day in the schedule, item s_{i,j} on i-th row and j-th column indicates team i play an away (resp., home) game with team |s_{i,j}| if s_{i,j}>0 (resp., s_{i,j}<0). 
